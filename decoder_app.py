import streamlit as st
import requests
import json
import time
from typing import List, Literal, TypedDict, Union


class Meta(TypedDict):
    namespace: str
    type: str
    coherence: float
    mediator: str
    timestamp: str


class Content(TypedDict):
    summary: str
    claims: List[str]
    context: str


class DecodeResultSuccess(TypedDict):
    status: Literal["success"]
    meta: Meta
    primes: List[int]
    content: Content


class DecodeResultError(TypedDict):
    status: Literal["error"]
    detail: str


DecodeResult = Union[DecodeResultSuccess, DecodeResultError]

# --- CONFIGURATION ---
# Point this to your actual backend URL
API_BASE = "https://dualsubstrate-commercial.fly.dev"
# For the demo, you might need a read-only API key or ensure the endpoint is open
# If closed, we can simulate the decode for the video based on the string structure.

st.set_page_config(
    page_title="Web4 Universal Resolver",
    page_icon="üåå",
    layout="centered",
    initial_sidebar_state="collapsed"
)

# --- STYLING (Monochrome Manifesto Style) ---
st.markdown("""
<style>
    .reportview-container {
        background: #fafafa;
    }
    h1 {
        font-family: 'Times New Roman', serif;
        font-weight: 400;
        color: #111;
    }
    .stTextInput input {
        font-family: 'Courier New', monospace;
        border-bottom: 2px solid #333;
    }
    .success-box {
        padding: 20px;
        border-left: 4px solid #10b981;
        background-color: #f0fdf4;
        font-family: 'Helvetica', sans-serif;
    }
    .metric-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        color: #666;
    }
</style>
""", unsafe_allow_html=True)

# --- MAIN UI ---

st.title("DualSubstrate // Resolver")
st.markdown("### Universal Coherence Decoder")

st.markdown("""
This tool demonstrates **Protocol Independence**. 
By inputting a Web4 Coordinate, any system with Ledger access can reconstruct the knowledge tree without a central platform.
""")

st.divider()

# INPUT
coordinate = st.text_input(
    "Enter Web4 Coordinate", 
    placeholder="e.g. PL-Conv-Alpha-7B4F2E91-2023-Q4-Thread-461",
    help="Paste the Prime Product or Ledger Key generated by the DualSubstrate engine."
)

def decode_coordinate(coord: str) -> DecodeResult:
    """
    Calls the backend to resolve the coordinate.
    """
    if len(coord) > 100 and coord.isdigit():
        return {
            "status": "error",
            "detail": "You pasted the Prime Product (Math). Please paste the Coordinate (e.g. PL-Conv...)"
        }

    try:
        # 1. VISUALIZATION: Fake "Math" processing delay
        with st.status("Establishing Coherence Handshake...", expanded=True) as status:
            st.write("üîç Parsing Namespace Prefix...")
            time.sleep(0.4)
            st.write("üßÆ Factorizing Hash Fragment...")
            time.sleep(0.4)
            st.write("üîê Verifying Ledger Integrity...")
            time.sleep(0.3)
            
            # 2. REAL API CALL
            response = requests.post(
                f"{API_BASE}/web4/decode",
                json={"coordinate": coord},
                headers={"Content-Type": "application/json"}
            )

            body = response.json()
            payload = body.get("data") or body.get("result") or body  # Handle nested payloads

            if response.ok and body.get("status") == "success":
                status.update(label="Handshake Verified", state="complete")
                meta = payload.get("meta")
                content = payload.get("content")

                if not meta or not content:
                    return {"status": "error", "detail": "Resolver returned an incomplete payload."}

                return {
                    "status": "success",
                    "meta": meta,
                    "primes": payload.get("primes", []),
                    "content": content
                }

            detail = payload.get("detail") or payload.get("error") or response.text
            status.update(label="Coherence Failed", state="error")
            return {"status": "error", "detail": detail}

    except requests.exceptions.RequestException as e:
        return {"status": "error", "detail": f"Network error: {e}"}
    except ValueError:
        return {"status": "error", "detail": "Resolver returned a non-JSON response."}
    except Exception as e:
        return {"status": "error", "detail": str(e)}

# RESOLVE BUTTON
if st.button("Resolve Coordinate", type="primary"):
    if not coordinate:
        st.error("Please enter a coordinate.")
    else:
        result: DecodeResult = decode_coordinate(coordinate)
        
        if result["status"] == "success":
            meta: Meta = result["meta"]
            
            # METRICS ROW
            c1, c2, c3 = st.columns(3)
            c1.metric("Coherence Norm", f"{meta['coherence']}")
            c2.metric("Mediator Prime", meta['mediator'])
            c3.metric("Type", meta['type'])
            
            st.divider()
            
            # RECONSTRUCTED CONTENT
            st.subheader("Reconstructed Knowledge Tree")
            
            content: Content = result["content"]
            
            st.markdown(f"""
            <div class="success-box">
                <b>Summary:</b> {content['summary']}
            </div>
            """, unsafe_allow_html=True)
            
            st.markdown("#### Key Claims (Prime Nodes)")
            for claim in content['claims']:
                st.markdown(f"- üóùÔ∏è *{claim}*")
                
            with st.expander("View Raw Ledger JSON"):
                st.json(result)
                
        else:
            st.error(f"Resolution Failed: {result['detail']}")
