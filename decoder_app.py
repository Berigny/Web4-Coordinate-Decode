import streamlit as st
import requests
import time
from typing import List, Literal, TypedDict, Union


class Meta(TypedDict, total=False):
    namespace: str
    type: str
    coherence: Union[float, str]
    mediator: str
    timestamp: str
    raw: dict


class Content(TypedDict, total=False):
    summary: str
    claims: List[str]
    context: str
    raw: dict


class DecodeResultSuccess(TypedDict, total=False):
    status: Literal["success"]
    meta: Meta
    primes: List[int]
    content: Content
    raw: dict


class DecodeResultError(TypedDict):
    status: Literal["error"]
    detail: str


DecodeResult = Union[DecodeResultSuccess, DecodeResultError]

# --- CONFIGURATION ---
# Point this to your actual backend URL
API_BASE = "https://dualsubstrate-commercial.fly.dev"
# For the demo, you might need a read-only API key or ensure the endpoint is open
# If closed, we can simulate the decode for the video based on the string structure.

st.set_page_config(
    page_title="Web4 Universal Resolver",
    page_icon="üåå",
    layout="centered",
    initial_sidebar_state="collapsed"
)

# --- STYLING (Monochrome Manifesto Style) ---
st.markdown("""
<style>
    .reportview-container {
        background: #fafafa;
    }
    h1 {
        font-family: 'Times New Roman', serif;
        font-weight: 400;
        color: #111;
    }
    .stTextInput input {
        font-family: 'Courier New', monospace;
        border-bottom: 2px solid #333;
    }
    .success-box {
        padding: 20px;
        border-left: 4px solid #10b981;
        background-color: #f0fdf4;
        font-family: 'Helvetica', sans-serif;
    }
    .metric-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        color: #666;
    }
</style>
""", unsafe_allow_html=True)

# --- MAIN UI ---

st.title("DualSubstrate // Resolver")
st.markdown("### Universal Coherence Decoder")

st.markdown("""
This tool demonstrates **Protocol Independence**. 
By inputting a Web4 Coordinate, any system with Ledger access can reconstruct the knowledge tree without a central platform.
""")

st.divider()

# INPUT
coordinate = st.text_input(
    "Enter Web4 Coordinate", 
    placeholder="e.g. PL-Conv-Alpha-7B4F2E91-2023-Q4-Thread-461",
    help="Paste the Prime Product or Ledger Key generated by the DualSubstrate engine."
)

def decode_coordinate(coord: str) -> DecodeResult:
    """
    Calls the backend to resolve the coordinate.
    """
    if len(coord) > 100 and coord.isdigit():
        return {
            "status": "error",
            "detail": "You pasted the Prime Product (Math). Please paste the Coordinate (e.g. PL-Conv...)"
        }

    def normalize_success(payload: dict) -> DecodeResultSuccess:
        """
        Normalize various resolver payload shapes into a consistent success object.
        """
        meta_source = payload.get("meta") or payload.get("metadata") or {}
        namespace_hint = payload.get("namespace_used") or payload.get("namespace")
        canonical_coord = payload.get("canonical_coord") or payload.get("coordinate") or coord

        normalized_meta: Meta = {
            "namespace": namespace_hint
                or meta_source.get("namespace")
                or coord.split(":")[0] if ":" in coord else coord,
            "type": meta_source.get("type") or meta_source.get("kind") or payload.get("kind") or "unknown",
            "coherence": meta_source.get("coherence")
                or meta_source.get("score")
                or meta_source.get("appraisal", {}).get("score", "N/A"),
            "mediator": meta_source.get("mediator") or meta_source.get("provider") or payload.get("provider", "N/A"),
            "timestamp": meta_source.get("timestamp")
                or payload.get("created_at")
                or meta_source.get("session_id", "N/A"),
            "raw": meta_source or payload,
        }

        content_payload = payload.get("content") or {}
        if not content_payload:
            content_payload = {
                "summary": payload.get("assistant_reply") or payload.get("full_text") or "No summary provided.",
                "claims": payload.get("knowledge_tree") or [],
                "context": payload.get("user_message") or canonical_coord,
            }

        normalized_content: Content = {
            "summary": content_payload.get("summary", "No summary provided."),
            "claims": content_payload.get("claims", []) or content_payload.get("knowledge_tree", []),
            "context": content_payload.get("context", payload.get("coordinate", "")),
            "raw": content_payload
        }

        return {
            "status": "success",
            "meta": normalized_meta,
            "primes": payload.get("primes") or payload.get("token_primes") or [],
            "content": normalized_content,
            "raw": payload
        }

    try:
        # 1. VISUALIZATION: Fake "Math" processing delay
        with st.status("Establishing Coherence Handshake...", expanded=True) as status:
            st.write("üîç Parsing Namespace Prefix...")
            time.sleep(0.4)
            st.write("üßÆ Factorizing Hash Fragment...")
            time.sleep(0.4)
            st.write("üîê Verifying Ledger Integrity...")
            time.sleep(0.3)
            
            # 2. REAL API CALL
            response = requests.post(
                f"{API_BASE}/web4/decode",
                json={"coordinate": coord},
                headers={"Content-Type": "application/json"}
            )

            body = response.json()
            payload = body.get("data") or body.get("result") or body  # Handle nested payloads

            # --- Known success envelope ---
            if response.ok and body.get("status") == "success":
                status.update(label="Handshake Verified", state="complete")
                return normalize_success(payload)

            # --- Explicit error envelope ---
            if body.get("status") == "error":
                detail = payload.get("detail") or payload.get("error") or response.text
                hint = payload.get("hint")
                if hint:
                    detail = f"{detail} ({hint})"
                status.update(label="Coherence Failed", state="error")
                return {"status": "error", "detail": detail}

            # --- Fallback: response is OK but shape is different (ledger record) ---
            looks_like_record = any(
                key in payload for key in ["coordinate", "metadata", "assistant_reply", "knowledge_tree", "token_primes"]
            )
            if response.ok and looks_like_record:
                status.update(label="Handshake Verified", state="complete")
                return normalize_success(payload)

            # --- Unknown failure ---
            detail = payload.get("detail") or payload.get("error") or response.text
            status.update(label="Coherence Failed", state="error")
            return {"status": "error", "detail": detail}

    except requests.exceptions.RequestException as e:
        return {"status": "error", "detail": f"Network error: {e}"}
    except ValueError:
        return {"status": "error", "detail": "Resolver returned a non-JSON response."}
    except Exception as e:
        return {"status": "error", "detail": str(e)}

# RESOLVE BUTTON
if st.button("Resolve Coordinate", type="primary"):
    if not coordinate:
        st.error("Please enter a coordinate.")
    else:
        result: DecodeResult = decode_coordinate(coordinate)
        
        if result.get("status") == "success":
            meta: Meta = result.get("meta") or {}
            content: Content = result.get("content") or {}
            raw_payload = result.get("raw") or {}
            
            # METRICS ROW
            c1, c2, c3 = st.columns(3)
            c1.metric("Coherence Norm", f"{meta.get('coherence', 'N/A')}")
            c2.metric("Mediator Prime", meta.get('mediator', meta.get('namespace', 'N/A')))
            c3.metric("Type", meta.get('type', 'N/A'))
            
            st.divider()
            
            # RECONSTRUCTED CONTENT
            st.subheader("Reconstructed Knowledge Tree")
            
            st.markdown(f"""
            <div class="success-box">
                <b>Summary:</b> {content.get('summary', 'No summary provided.')}
            </div>
            """, unsafe_allow_html=True)
            
            st.markdown("#### Key Claims (Prime Nodes)")
            claims = content.get('claims') or []
            if claims:
                for claim in claims:
                    st.markdown(f"- üóùÔ∏è *{claim}*")
            else:
                st.caption("No discrete prime nodes returned; displaying raw payload below.")

            walk_kind = raw_payload.get("kind") or meta.get("type")
            walk_path = raw_payload.get("path") if isinstance(raw_payload, dict) else None
            if walk_kind == "coord_walk" and isinstance(walk_path, list):
                st.divider()
                st.subheader("Walk Inspection")
                show_hop_numbers = st.checkbox("Show hop numbers", value=True)
                for idx, coord in enumerate(walk_path):
                    if not isinstance(coord, str):
                        continue
                    if show_hop_numbers:
                        st.markdown(f"{idx}. `{coord}`")
                    else:
                        st.markdown(f"- `{coord}`")

            with st.expander("View Raw Ledger JSON"):
                st.json(result.get("raw") or result)
                
        else:
            detail = result.get("detail", "Unknown error")
            st.error(f"Resolution Failed: {detail}")
